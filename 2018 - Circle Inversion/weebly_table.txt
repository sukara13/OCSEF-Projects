  <style>
	.tabstrip
	{
		width: 525px;
		height: 620px;
		margin: auto;
	}    
	 
	.tabstrip ul,
	.tabstrip li
	{
		margin: 0;
		padding: 0;
		list-style: none;
	}
	 
	.tabstrip,
	.tabstrip input[type="radio"]:checked + label
	{
		position: relative;
	}
	 
	.tabstrip li,
	.tabstrip input[type="radio"] + label
	{
		display: inline-block;
	}
	 
	.tabstrip li > div,
	.tabstrip input[type="radio"]
	{
		position: absolute;
	}
	 
	.tabstrip li > div,
	.tabstrip input[type="radio"] + label
	{
		border: solid 1px #ccc;
	}
	 
	.tabstrip
	{
		font: bold 14px Arial, Sans-serif;
		color: #404040;
	}
	 
	.tabstrip li
	{
		vertical-align: top;
	}
	 
	.tabstrip li:first-child
	{
		margin-left: 8px;
	}
	 
	.tabstrip li > div
	{
		top: 33px;
		bottom: 0;
		left: 0;
		width: 100%;
		padding: 8px;
		overflow: auto;
		background: #fff;
		-moz-box-sizing: border-box;
		-webkit-box-sizing: border-box;
		box-sizing: border-box;
	}
	 
	.tabstrip input[type="radio"] + label
	{
		margin: 0 2px 0 0;
		padding: 0 18px;
		line-height: 32px;
		background: #f1f1f1;
		text-align: center;
		border-radius: 5px 5px 0 0;
		cursor: pointer;
		-moz-user-select: none;
		-webkit-user-select: none;
		user-select: none;
	}
	 
	.tabstrip input[type="radio"]:checked + label
	{
		z-index: 1;
		background: #fff;
		border-bottom-color: #fff;
		cursor: default;
	}
	 
	.tabstrip input[type="radio"]
	{
		opacity: 0;
	}
	 
	.tabstrip input[type="radio"] ~ div
	{
		display: none;
	}
	 
	.tabstrip input[type="radio"]:checked:not(:disabled) ~ div
	{
		display: block;
	}
	 
	.tabstrip input[type="radio"]:disabled + label
	{
		opacity: .5;
		cursor: no-drop;
	}

	.fieldset
	{
		font: bold 12px Arial, Sans-serif;
		color: #404040;
		border: 1px solid gray;
	}

	.legend
	{
		margin-left: 10px;
	}

	.h1
	{
		font: bold 20px Arial, Sans-serif;
		color: #404040;
		text-align: center;
	}

	.button
	{
		text-align:left;
		width:200px
	}

	.number
	{
		color: black;
		width: 50px;
		height: 18px;
		padding-left: 3px;
		border: 0.01em solid #A0A0A0;
	}
	
	.canvas
	{
		border:1px solid gray;
	}
  </style>
	<div class="tabstrip">
		<ul>
			<li>
				<input type="radio" name="tabstrip-0" checked="checked" id="tabstrip-0-0" /><label for="tabstrip-0-0">Invert Point</label>
				<div>
					<table border="0" width="100%">
						<tr>
							<td colspan="3" align="left">
								<fieldset class="fieldset" style="width:500px; height:95px">
									<legend align="left" class="legend">Load Template</legend>
									<table border="0" width="100%">
										<tr align="center">
											<td align="center"><button onclick="invertPointByCircle(120, 120)" class="button">Point inside circle</button></td>
											<td align="center"><button onclick="invertPointByCircle(160, 160)" class="button">Point outside circle</button></td>
										</tr>
										<tr align="center">
											<td align="center"><button onclick="invertPointByCircle(100, 120)" class="button">Point inside vertical</button></td>
											<td align="center"><button onclick="invertPointByCircle(180, 100)" class="button">Point outside horizontal</button></td>
										</tr>
										<tr align="center">
											<td align="center"><button onclick="invertPointByCircle(124, 132)" class="button">Point on circle</button></td>
											<td align="center"><button onclick="invertPointByCircle(100, 100)" class="button">Point at center</button></td>
										</tr>
									</table>
								</fieldset>
							</td>
						</tr>
						<tr valign="top">
							<td align="left">
								<fieldset class="fieldset" style="color:blue; width:163px; height:110px">
									<legend align="left" class="legend">Inversion Circle</legend>
									<table border="0">
										<tr>
											<td align="left">Center X:</td>
											<td align="left"><input id="ic1X" type="number" min="0" max="400" class="number"></td>
										</tr>
										<tr>
											<td align="left">Center Y:</td>
											<td align="left"><input id="ic1Y" type="number" min="0" max="200" class="number"></td>
										</tr>
										<tr>
											<td align="left">Radius:</td>
											<td align="left"><input id="ic1R" type="number" min="1" max="200" class="number"></td>
										</tr>
									</table>
								</fieldset>
							</td>
							<td align="left">
								<fieldset class="fieldset" style="color:green; width:163px; height:110px">
									<legend align="left" class="legend">Original Point</legend>
									<table border="0">
										<tr>
											<td align="left">X:</td>
											<td align="left"><input id="opX" type="number" min="0" max="400" class="number"></td>
										</tr>
										<tr>
											<td align="left">Y:</td>
											<td align="left"><input id="opY" type="number" min="0" max="200" class="number"></td>
										</tr>
										<tr>
											<td align="left">|OP|:</td>
											<td align="left"><label id="opD"></label></td>
										</tr>
									</table>
								</fieldset>
							</td>
							<td align="left">
								<fieldset class="fieldset" style="color:red; width:163px; height:110px">
									<legend align="left" class="legend">Inverted Point</legend>
									<table border="0">
										<tr>
											<td align="left">X:</td>
											<td align="left"><label id="ipX"></label></td>
										</tr>
										<tr>
											<td align="left">Y:</td>
											<td align="left"><label id="ipY"></label></td>
										</tr>
										<tr>
											<td align="left">|OP'|:</td>
											<td align="left"><label id="ipD"></label></td>
										</tr>
										<tr>
											<td align="left">|OP|.|OP'|:</td>
											<td align="left"><label id="ipDxopD"></label></td>
										</tr>
										<tr>
											<td align="left">R<sup>2</sup>:</td>
											<td align="left"><label id="icRxicR"></label></td>
										</tr>
									</table>
								</fieldset>
							</td>
						</tr>
						<tr>
							<td colspan="2" align="left" style="padding-left:10px"><button onclick="invertPointCustom()">Invert Point</button></td>
							<td align="right" style="padding-right:10px"><label id="lblMousePosPoint" style="font-size:10px"></label></td>
						</tr>
						<tr>
							<td colspan="3" align="left">
								<canvas id="canvasPoint" width="500" height="200" class="canvas"></canvas>
							</td>
						</tr>
					</table>
				</div>
			</li>
			<li>
				<input type="radio" name="tabstrip-0" id="tabstrip-0-1" /><label for="tabstrip-0-1">Invert Circle</label>
				<div>
					<table border="0" width="100%">
						<tr>
							<td colspan="3">
								<fieldset class="fieldset" style="width:500px; height:197px">
									<legend align="left" class="legend">Load Template</legend>
									<table border="0" width="100%">
										<tr align="center">
											<td align="center"><button onclick="invertCircleByCircle(120, 100, 10)" class="button">Circle inside</button></td>
											<td align="center"><button onclick="invertCircleByCircle(200, 100, 50)" class="button">Circle outside</button></td>
										</tr>
										<tr align="center">
											<td align="center"><button onclick="invertCircleByCircle(150, 100, 20)" class="button">Circle intersect - small</button></td>
											<td align="center"><button onclick="invertCircleByCircle(150, 100, 70)" class="button">Circle intersect - large</button></td>
										</tr>
										<tr align="center">
											<td align="center"><button onclick="invertCircleByCircle(130, 100, 30)" class="button">Circle pass center - horizontal</button></td>
											<td align="center"><button onclick="invertCircleByCircle(100, 130, 30)" class="button">Circle pass center - vertical</button></td>
										</tr>
										<tr align="center">
											<td align="center"><button onclick="invertCircleByCircle(130, 140, 50)" class="button">Circle pass center - tilted</button></td>
											<td align="center"><button onclick="invertCircleByCircle(106, 108, 10)" class="button">Circle pass center - inside</button></td>
										</tr>
										<tr align="center">
											<td align="center"><button onclick="invertCircleByCircle(120, 100, 20)" class="button">Circle pass center - tangent</button></td>
											<td align="center"><button onclick="invertCircleByCircle(100, 100, 20)" class="button">Concentric circle - inside</button></td>
										</tr>
										<tr align="center">
											<td align="center"><button onclick="invertCircleByCircle(100, 100, 60)" class="button">Concentric circle - outside</button></td>
											<td align="center"><button onclick="invertCircleByCircle(90, 100, 25)" class="button">Nonconcentric circle - inside</button></td>
										</tr>
										<tr align="center">
											<td align="center"><button onclick="invertCircleByCircle(90, 100, 60)" class="button">Nonconcentric circle - outside</button></td>
											<td align="center"><button onclick="invertCircleByCircle(150, 100, 30)" class="button">Orthogonal circle</button></td>
										</tr>
									</table>
								</fieldset>
							</td>
						</tr>
						<tr valign="top">
							<td align="left">
								<fieldset class="fieldset" style="color:blue; width:163px; height:90px">
									<legend align="left" class="legend">Inversion Circle</legend>
									<table border="0">
										<tr>
											<td align="left">Center X:</td>
											<td align="left"><input id="ic2X" type="number" min="0" max="400" class="number"></td>
										</tr>
										<tr>
											<td align="left">Center Y:</td>
											<td align="left"><input id="ic2Y" type="number" min="0" max="200" class="number"></td>
										</tr>
										<tr>
											<td align="left">Radius:</td>
											<td align="left"><input id="ic2R" type="number" min="1" max="200" class="number"></td>
										</tr>
									</table>
								</fieldset>
							</td>
							<td align="left">
								<fieldset class="fieldset" style="color:green; width:163px; height:90px">
									<legend align="left" class="legend">Original Circle</legend>
									<table border="0">
										<tr>
											<td align="left">Center X:</td>
											<td align="left"><input id="ocX" type="number" min="0" max="400" class="number"></td>
										</tr>
										<tr>
											<td align="left">Center Y:</td>
											<td align="left"><input id="ocY" type="number" min="0" max="200" class="number"></td>
										</tr>
										<tr>
											<td align="left">Radius:</td>
											<td align="left"><input id="ocR" type="number" min="1" max="200" class="number"></td>
										</tr>
									</table>
								</fieldset>
							</td>
							<td align="left">
								<fieldset class="fieldset" style="color:red; width:163px; height:90px">
									<legend align="left" class="legend">Inverted Circle</legend>
									<table border="0">
										<tr>
											<td align="left">Center X:</td>
											<td align="left"><label id="icX"></label></td>
										</tr>
										<tr>
											<td align="left">Center Y:</td>
											<td align="left"><label id="icY"></label></td>
										</tr>
										<tr>
											<td align="left">Radius:</td>
											<td align="left"><label id="icR"></label></td>
										</tr>
										<tr>
											<td colspan="2">Line: <label id="icL"></label></td>
										</tr>
									</table>
								</fieldset>
							</td>
						</tr>
						<tr>
							<td colspan="2" align="left" style="padding-left:10px"><button onclick="invertCircleCustom()">Invert Circle</button></td>
							<td align="right" style="padding-right:10px"><label id="lblMousePosCircle" style="font-size:10px"></label></td>
						</tr>
						<tr>
							<td colspan="3" align="center">
								<canvas id="canvasCircle" width="500" height="200" class="canvas"></canvas>
							</td>
						</tr>
					</table>
				</div>
			</li>
			<li>
				<input type="radio" name="tabstrip-0" id="tabstrip-0-2" /><label for="tabstrip-0-2">Pappus Chain</label>
				<div>
					<table border="0" width="100%">
						<tr>
							<td colspan="3">
								<fieldset class="fieldset" style="width:500px; height:70px">
									<legend align="left" class="legend">Load Template</legend>
									<table border="0" width="100%">
										<tr align="center">
											<td align="center"><button onclick="createPappusChain(60, 40, 100, 40)" class="button">Pappus Chain - right side</button></td>
											<td align="center"><button onclick="createPappusChain(60, 40, 40, 100)" class="button">Pappus Chain - left side</button></td>
										</tr>
										<tr align="center">
											<td align="center"><button onclick="createPappusChain(60, 40, 70, 70)" class="button">Pappus Chain - both sides</button></td>
											<td align="center"><button onclick="createInvertPappusChain(60, 40, 80, 20)" class="button">Pappus Chain - invert circles</button></td>
										</tr>
									</table>
								</fieldset>
							</td>
						</tr>
						<tr valign="top">
							<td align="left">
								<fieldset class="fieldset" style="color:blue; width:163px; height:110px">
									<legend align="left" class="legend">Inversion Circle</legend>
									<table border="0">
										<tr>
											<td align="left">Center X:</td>
											<td align="left"><label id="ic3X"></label></td>
										</tr>
										<tr>
											<td align="left">Center Y:</td>
											<td align="left"><label id="ic3Y"></label></td>
										</tr>
										<tr>
											<td align="left">Radius:</td>
											<td align="left"><label id="ic3R"></label></td>
										</tr>
									</table>
								</fieldset>
							</td>
							<td align="left">
								<fieldset class="fieldset" style="color:green; width:163px; height:110px">
									<legend align="left" class="legend">Semicircles</legend>
									<table border="0">
										<tr>
											<td align="left">Left Corner X:</td>
											<td align="left"><input id="lcX" type="number" min="0" max="400" class="number"></td>
										</tr>
										<tr>
											<td align="left">Left Corner Y:</td>
											<td align="left"><input id="lcY" type="number" min="0" max="200" class="number"></td>
										</tr>
										<tr>
											<td align="left">Left Radius:</td>
											<td align="left"><input id="lsR" type="number" min="1" max="200" class="number"></td>
										</tr>
										<tr>
											<td align="left">Right Radius:</td>
											<td align="left"><input id="rsR" type="number" min="1" max="200" class="number"></td>
										</tr>
									</table>
								</fieldset>
							</td>
							<td align="left">
								<fieldset class="fieldset" style="color:red; width:163px; height:110px">
									<legend align="left" class="legend">Pappus Chain</legend>
									<table border="0">
										<tr>
											<td align="left">O1) H/D:</td>
											<td align="left"><label id="pcO1"></label></td>
										</tr>
										<tr>
											<td align="left">O2) H/D:</td>
											<td align="left"><label id="pcO2"></label></td>
										</tr>
										<tr>
											<td align="left">O3) H/D:</td>
											<td align="left"><label id="pcO3"></label></td>
										</tr>
										<tr>
											<td align="left">O4) H/D:</td>
											<td align="left"><label id="pcO4"></label></td>
										</tr>
										<tr>
											<td align="left">O5) H/D:</td>
											<td align="left"><label id="pcO5"></label></td>
										</tr>
									</table>
								</fieldset>
							</td>
						</tr>
						<tr>
							<td colspan="2" align="left" style="padding-left:10px"><button onclick="createPappusChainCustom()">Create</button>
							<button onclick="invertPappusChainCircles()">Invert</button>
							<button onclick="showPappusChainHomothety()">Homothety</button></td>
							<td align="right" style="padding-right:10px"><label id="lblMousePosPappus" style="font-size:10px"></label></td>
						</tr>
						<tr>
							<td colspan="3" align="center">
								<canvas id="canvasPappus" width="500" height="200" class="canvas"></canvas>
							</td>
						</tr>
					</table>
				</div>
			</li>
		</ul>
	</div>
	<script>
		// color of the inversion circle
		var COLOR_INVERSION_CIRCLE = 'blue';
		
		// color of the original point or circle
		var COLOR_ORIGINAL = 'green';
		
		// color of the inverted point or circle
		var COLOR_INVERTED = 'red';
		
		// x coordinate of the center of the inversion circle
		var INVERSION_CIRCLE_CENTER_X = 100;
		
		// y coordinate of the center of the inversion circle
		var INVERSION_CIRCLE_CENTER_Y = 100;
		
		// radius of the inversion circle
		var INVERSION_CIRCLE_RADIUS = 40;
		
		// minimum radius of a circle to display in the pappus chain
		var MIN_RADIUS_TO_DISPLAY_IN_PAPPUS_CHAIN = 0.01
		
		// number of circles to display in the pappus chain
		var PAPPUS_CHAIN_CIRCLE_COUNT = 10;
		
		// number of circles in the pappus chain to invert
		var PAPPUS_CHAIN_INVERSE_COUNT = 5;
		
		// width of a canvas to display points, circles, and lines
		var CANVAS_WIDTH = 500;
		
		// height of a canvas to display points, circles, and lines
		var CANVAS_HEIGHT = 200;
		
		// canvas in the first tab to display point inversion
		var canvasPoint = document.getElementById('canvasPoint');
		
		// canvas in the second tab to display circle inversion
		var canvasCircle = document.getElementById('canvasCircle');
		
		// canvas in the third tab to display pappus chain
		var canvasPappus = document.getElementById('canvasPappus');
		
		// context to draw 2-D shapes on the point canvas
		var contextPoint = canvasPoint.getContext('2d');
		
		// context to draw 2-D shapes on the circle canvas
		var contextCircle = canvasCircle.getContext('2d');
		
		// context to draw 2-D shapes on the pappus canvas
		var contextPappus = canvasPappus.getContext('2d');
		
		// boolean flag to show.hide homothety lines
		var showHomothety = false;
		
		// features of the inversion circle centered at the left or right corner of the big semicircle
		// semicircles and circles in the pappus chain will be inverted with respect to this inversion circle
		var icPappusChain = {
			'centerX': '',
			'centerY': '',
			'radius': ''
		}
		
		// show mouse position in the point canvas
		canvasPoint.addEventListener('mousemove', function(evt) {
			var mousePos = getMousePos(canvasPoint, evt);
			lblMousePosPoint.innerHTML = 'Mouse Position: (' + Math.round(mousePos.x) + ',' + Math.round(canvasPoint.height-mousePos.y) + ')';
		}, false);

		// show mouse position in the circle canvas
		canvasCircle.addEventListener('mousemove', function(evt) {
			var mousePos = getMousePos(canvasCircle, evt);
			lblMousePosCircle.innerHTML = 'Mouse Position: (' + Math.round(mousePos.x) + ',' + Math.round(canvasCircle.height-mousePos.y) + ')';
		}, false);

		// show mouse position in the pappus canvas
		canvasPappus.addEventListener('mousemove', function(evt) {
			var mousePos = getMousePos(canvasPappus, evt);
			lblMousePosPappus.innerHTML = 'Mouse Position: (' + Math.round(mousePos.x) + ',' + Math.round(canvasPappus.height-mousePos.y) + ')';
		}, false);

		// get mouse position from a specified canvas
		function getMousePos(canvas, evt) {
			var rect = canvas.getBoundingClientRect();
			return {
			  x: evt.clientX - rect.left,
			  y: evt.clientY - rect.top
			};
		}
		
		// calculate the distance between two points
		function distanceBetweenTwoPoints(x1, y1, x2, y2) {
			// use the pythagorean theorem to calculate the hypotenuse from rise and run
			return (Math.sqrt(Math.pow(x1-x2,2) + Math.pow(y1-y2,2))).toFixed(2);
		}
		
		// invert a specific point with respect to the inversion circle
		function invertPointByCircle(opX, opY){
			// invert the original point with respect to the inversion circle and draw inversion circle, original point, and inverted point
			invertPointAndDraw(INVERSION_CIRCLE_CENTER_X, INVERSION_CIRCLE_CENTER_Y, INVERSION_CIRCLE_RADIUS, opX, opY);
		}
		
		// invert a point and draw on the canvas
		function invertPointAndDraw(icX, icY, icR, opX, opY){
			// clear canvas
			contextPoint.clearRect(0, 0, canvasPoint.width, canvasPoint.height);
			
			// set inversion circle textboxes
			document.getElementById('ic1X').value = icX;
			document.getElementById('ic1Y').value = icY;
			document.getElementById('ic1R').value = icR;
			
			// draw inversion circle
			drawCircle(contextPoint, icX, icY, icR, COLOR_INVERSION_CIRCLE, 'white', 1, true);
			
			// set original point and invert with respect to the inversion circle
			drawPoint(contextPoint, opX, opY, COLOR_ORIGINAL);
			var invertedPoint = invertPoint(contextPoint, icX, icY, icR, opX, opY, COLOR_INVERTED);
			
			// set point textboxes and labels
			setPointBoxes(icX, icY, icR, opX, opY, opD, invertedPoint);
		}
		
		// invert a custom point entered by the user
		function invertPointCustom(){
			// get the original point and inversion circle entered by the user
			var icX = parseInt(document.getElementById('ic1X').value);
			var icY = parseInt(document.getElementById('ic1Y').value);
			var icR = parseInt(document.getElementById('ic1R').value);
			var opX = parseInt(document.getElementById('opX').value);
			var opY = parseInt(document.getElementById('opY').value);
			
			// invert the original point with respect to the inversion circle
			invertPointAndDraw(icX, icY, icR, opX, opY);
		}
		
		// invert a specific circle with respect to the inversion circle
		function invertCircleByCircle(ocX, ocY, ocR){
			// invert original circle with respect to the inversion circle and draw inversion circle, original circle, and inverted circle
			invertCircleAndDraw(INVERSION_CIRCLE_CENTER_X, INVERSION_CIRCLE_CENTER_Y, INVERSION_CIRCLE_RADIUS, ocX, ocY, ocR);
		}
		
		// invert a circle and draw on the canvas
		function invertCircleAndDraw(icX, icY, icR, ocX, ocY, ocR){
			// clear canvas
			contextCircle.clearRect(0, 0, canvasCircle.width, canvasCircle.height);
			
			// set inversion circle textboxes
			document.getElementById('ic2X').value = icX;
			document.getElementById('ic2Y').value = icY;
			document.getElementById('ic2R').value = icR;
			
			// draw inversion circle
			drawCircle(contextCircle, icX, icY, icR, COLOR_INVERSION_CIRCLE, 'white', 0.7, true);
			
			// draw original circle and invert with respect to the inversion circle
			drawCircle(contextCircle, ocX, ocY, ocR, COLOR_ORIGINAL, 'white', 0.7, true);
			setOriginalCircleBoxes(ocX, ocY, ocR);
			var invertedCircle = invertCircle(contextCircle, icX, icY, icR, ocX, ocY, ocR, COLOR_INVERTED, 'white', 0.7);
			setInvertedCircleBoxes(invertedCircle);
		}
		
		// invert a custom circle entered by the user
		function invertCircleCustom(){
			// get the original circle and inversion circle entered by the user
			var icX = parseInt(document.getElementById('ic2X').value);
			var icY = parseInt(document.getElementById('ic2Y').value);
			var icR = parseInt(document.getElementById('ic2R').value);
			var ocX = parseInt(document.getElementById('ocX').value);
			var ocY = parseInt(document.getElementById('ocY').value);
			var ocR = parseInt(document.getElementById('ocR').value);
			
			// invert the original circle with respect to the inversion circle
			invertCircleAndDraw(icX, icY, icR, ocX, ocY, ocR);
		}
		
		// create a pappus chain for two semicircles specified by the left corner and each radius
		function createPappusChain(lcX, lcY, r1, r2, showIC){
			// clear canvas
			contextPappus.clearRect(0, 0, canvasPappus.width, canvasPappus.height);
			
			// show inversion circle
			if (showIC) {
				// left semicircle is greater than or equal to right semicircle
				if (r1 >= r2) {
					// center of inversion circle should be at the left corner of semicircles
					icPappusChain.centerX = lcX;
					icPappusChain.centerY = lcY;
				}
				else {
					// center of inversion circle should be at the right corner of semicircles
					icPappusChain.centerX = lcX + 2*(r1+r2);
					icPappusChain.centerY = lcY;
				}
				
				// set the radius of the inversion circle
				icPappusChain.radius = 2*(r1+r2);

				// draw inversion circle
				drawCircle(contextPappus, icPappusChain.centerX, icPappusChain.centerY, icPappusChain.radius, COLOR_INVERSION_CIRCLE, 'white', 1);

				// set inversion circle textboxes
				document.getElementById('ic3X').innerHTML = icPappusChain.centerX;
				document.getElementById('ic3Y').innerHTML = icPappusChain.centerY;
				document.getElementById('ic3R').innerHTML = icPappusChain.radius;
			}
			else {
				// reset inversion circle textboxes
				document.getElementById('ic3X').innerHTML = '';
				document.getElementById('ic3Y').innerHTML = '';
				document.getElementById('ic3R').innerHTML = '';
			}
			
			// draw pappus chain
			var pappusChain = drawPappusChain(contextPappus, lcX, lcY, r1, r2);
			setPappusChainBoxes(pappusChain);
			
			// set semicircle textboxes
			document.getElementById('lcX').value = lcX;
			document.getElementById('lcY').value = lcY;
			document.getElementById('lsR').value = r1;
			document.getElementById('rsR').value = r2;
		}
		
		// create a pappus chain and invert the inscribed circles and semicircles
		function createInvertPappusChain(lcX, lcY, r1, r2){
			// create pappus chain
			createPappusChain(lcX, lcY, r1, r2, true);
			
			// invert pappus chain
			invertPappusChain(contextPappus, icPappusChain.centerX, icPappusChain.centerY, lcX, lcY, r1, r2);
		}
		
		// create a pappus chain entered by the user
		function createPappusChainCustom(){
			// get the left corner coordinates and semicircle radius entered by the user
			var lcX = parseInt(document.getElementById('lcX').value);
			var lcY = parseInt(document.getElementById('lcY').value);
			var r1 = parseInt(document.getElementById('lsR').value);
			var r2 = parseInt(document.getElementById('rsR').value);
			
			// create pappus chain
			createPappusChain(lcX, lcY, r1, r2);
		}
		
		// invert a pappus chain entered by the user
		function invertPappusChainCircles(){
			// get the left corner coordinates and semicircle radius entered by the user
			var lcX = parseInt(document.getElementById('lcX').value);
			var lcY = parseInt(document.getElementById('lcY').value);
			var r1 = parseInt(document.getElementById('lsR').value);
			var r2 = parseInt(document.getElementById('rsR').value);
			
			// create pappus chain
			createPappusChain(lcX, lcY, r1, r2, true);
			
			// invert pappus chain
			invertPappusChain(contextPappus, icPappusChain.centerX, icPappusChain.centerY, lcX, lcY, r1, r2);
		}

		// show homothety lines on an inverted pappus chain
		function showPappusChainHomothety(){
			// enable homothety
			showHomothety = true;
			
			// invert pappus chain
			invertPappusChainCircles();

			// disable homothety
			showHomothety = false;
		}
		
		// draw a point
		function drawPoint(context, x, y, color) {
			context.beginPath();
			context.arc(x, CANVAS_HEIGHT-y, 1, 0, Math.PI * 2, true);
			context.fillStyle = color;
			context.fill();
		}

		// draw a line
		function drawLine(context, startX, startY, endX, endY, color) {
			context.beginPath();
			context.moveTo(startX, CANVAS_HEIGHT-startY);
			context.lineTo(endX, CANVAS_HEIGHT-endY);
			context.lineWidth = 1;
			context.strokeStyle = color;
			context.stroke();
		}

		// draw a circle
		function drawCircle(context, centerX, centerY, radius, circleColor, fillColor, transparency, showCenter) {
			drawCircleWithAngle(context, centerX, centerY, radius, 2, circleColor, fillColor, transparency);
			if (showCenter)
				drawPoint(context, centerX, centerY, circleColor);
		}

		// draw a semicircle
		function drawSemicircle(context, centerX, centerY, radius, circleColor, fillColor, transparency, showCenter) {
			drawCircleWithAngle(context, centerX, centerY, radius, 1, circleColor, fillColor, transparency);
			if (showCenter)
				drawPoint(context, centerX, centerY, circleColor);
		}

		// common method to draw a circle or semicircle by specifying an angle in pi radians
		// set the angle to 1 for a semicircle, and 2 for a circle
		function drawCircleWithAngle(context, centerX, centerY, radius, angle, circleColor, fillColor, transparency) {
			context.beginPath();
			context.globalAlpha = transparency;
			context.arc(centerX, CANVAS_HEIGHT-centerY, radius, 0, angle * Math.PI, true);
			context.fillStyle = fillColor;
			context.fill();
			context.lineWidth = 1;
			context.strokeStyle = circleColor;
			context.stroke();
		}

		// set the textboxes and labels for the original and inverted points
		function setPointBoxes(icX, icY, icR, opX, opY, opD, invertedPoint) {
			// calculate OP as the distance from the center of the inversion circle to the original point
			var opD = distanceBetweenTwoPoints(icX, icY, opX, opY);
			
			// set the features of the original point
			document.getElementById('opX').value = opX;
			document.getElementById('opY').value = opY;
			document.getElementById('opD').innerHTML = opD;

			// set the features of the inverted point
			document.getElementById('ipX').innerHTML = invertedPoint.x;
			document.getElementById('ipY').innerHTML = invertedPoint.y;
			document.getElementById('ipD').innerHTML = invertedPoint.d;
			document.getElementById('ipDxopD').innerHTML = (invertedPoint.d*opD).toFixed(2);
			document.getElementById('icRxicR').innerHTML = (Math.pow(icR,2)).toFixed(2);
		}

		// set the textboxes for the original circle
		function setOriginalCircleBoxes(x, y, r) {
			document.getElementById('ocX').value = x;
			document.getElementById('ocY').value = y;
			document.getElementById('ocR').value = r;
		}

		// set the labels for the inverted circle
		function setInvertedCircleBoxes(invertedCircle) {
			document.getElementById('icX').innerHTML = invertedCircle.x;
			document.getElementById('icY').innerHTML = invertedCircle.y;
			document.getElementById('icR').innerHTML = invertedCircle.r;
			document.getElementById('icL').innerHTML = invertedCircle.l;
		}

		// set the labels for the pappus chain
		function setPappusChainBoxes(pappusChain) {
			document.getElementById('pcO1').innerHTML = Math.round(pappusChain[0].height) + ' / ' + Math.round(pappusChain[0].radius * 2) + ' = ' + Math.round(pappusChain[0].height / (pappusChain[0].radius * 2));
			document.getElementById('pcO2').innerHTML = Math.round(pappusChain[1].height) + ' / ' + Math.round(pappusChain[1].radius * 2) + ' = ' + Math.round(pappusChain[1].height / (pappusChain[1].radius * 2));
			document.getElementById('pcO3').innerHTML = Math.round(pappusChain[2].height) + ' / ' + Math.round(pappusChain[2].radius * 2) + ' = ' + Math.round(pappusChain[2].height / (pappusChain[2].radius * 2));
			document.getElementById('pcO4').innerHTML = Math.round(pappusChain[3].height) + ' / ' + Math.round(pappusChain[3].radius * 2) + ' = ' + Math.round(pappusChain[3].height / (pappusChain[3].radius * 2));
			document.getElementById('pcO5').innerHTML = Math.round(pappusChain[4].height) + ' / ' + Math.round(pappusChain[4].radius * 2) + ' = ' + Math.round(pappusChain[4].height / (pappusChain[4].radius * 2));
		}

		// invert an original point with respect to an inversion circle
		function invertPoint(context, icX, icY, icR, opX, opY, color) {
			// initialize the inverted point to blank values
			var invertedPoint = {
				'x': '',
				'y': '',
				'd': ''
			}
			
			// original point is at the center of the inversion circle
			if (opX == icX && opY == icY) {
				// no inversion
				alert('No inversion because the point is at the center of the inversion circle.');
			}
			// original point is on the inversion circle
			else if (Math.pow(opX-icX,2) + Math.pow(opY-icY,2) - Math.pow(icR,2) > -1 && Math.pow(opX-icX,2) + Math.pow(opY-icY,2) - Math.pow(icR,2) < 1) {
				// invert onto itself
				invertedPoint.x = opX;
				invertedPoint.y = opY;
				invertedPoint.d = icR;
				drawPoint(context, opX, opY, color);
			}
			// original point is either inside or outside the inversion circle
			else {
				// http://mathworld.wolfram.com/Inversion.html
				// calculate the coordinates of the inverted point
				a = Math.pow(icR,2) / (Math.pow(opX-icX,2) + Math.pow(opY-icY,2));
				invertedPoint.x = Math.round(a*(opX - icX) + icX);
				invertedPoint.y = Math.round(a*(opY - icY) + icY);
				drawPoint(context, invertedPoint.x, invertedPoint.y, color);

				// calculate OP' as the distance from the center of the inversion circle to the inverted point
				invertedPoint.d = distanceBetweenTwoPoints(icX, icY, invertedPoint.x, invertedPoint.y);
			}
			
			// return the inverted point
			return invertedPoint;
		}

		// invert an original circle with respect to an inversion circle
		function invertCircle(context, icX, icY, icR, ocX, ocY, ocR, circleColor, fillColor, transparency) {
			// initialize the inverted circle to blank values
			var invertedCircle = {
				'x': '',
				'y': '',
				'r': '',
				'l': ''
			}
			
			// http://mathworld.wolfram.com/Inversion.html
			// calculate the denominator of s = icR^2 / ((ocX-icX)^2 + (ocY-icY)^2 - ocR^2)
			denom = Math.pow(ocX-icX,2) + Math.pow(ocY-icY,2) - Math.pow(ocR,2);
			
			// original circle that passes through the center of the inversion circle will be inverted as a line
			if (denom > -1 && denom < 1) {
				// circles don't intersect, but may be tangent
				// diameter of the original circle is less than or equal to the radius of the inversion circle
				if (2*ocR <= icR) {
					// inverted line will be outside the inversion circle
					// find the coordinates of the point on the original circle that is one diameter away from the center of the inversion circle
					xd = icX + 2*(ocX-icX);
					yd = icY + 2*(ocY-icY);
					
					// invert that point with respect to the inversion circle for the inverted line to pass through
					a = Math.pow(icR,2) / (Math.pow(xd-icX,2) + Math.pow(yd-icY,2));
					ix1 = a*(xd - icX) + icX;
					iy1 = a*(yd - icY) + icY;
					
					// y coordinates of the original and inversion circles are the same
					if (icY == ocY) {
						// inverted line is vertical
						ix0 = ix1;
						iy0 = 0;
						ixn = ix1;
						iyn = CANVAS_HEIGHT;
					}
					else {
						// calculate the slope of the diameter
						md = (ocY-icY) / (ocX-icX);
						
						// calculate the slope of the line that is perpendicular to the diameter
						ml = -1/md;
						
						// calculate the intercept from y = mx + b
						b = iy1 - ml*ix1;

						// Use the equation of the line perpendicular to the diameter
						ix0 = 0;
						iy0 = ml*ix0 + b;
						ixn = CANVAS_WIDTH;
						iyn = ml*ixn + b;
					}
				}
				else {
					// http://www.ambrsoft.com/TicRgoCalc/Circles2/circle2intersection/CircleCircleIntersection.htm
					// distance between the centers of the original and inversion circles
					d = ocR; //Math.sqrt(Math.pow(ocX-icX,2) + Math.pow(ocY-icY,2))
					a = Math.sqrt((d+ocR+icR)*(d+ocR-icR)*(d-ocR+icR)*(-d+ocR+icR)) / 4;
					
					// find the intersection points for the inverted line to pass through
					ix1 = (ocX+icX)/2 + (icX-ocX)*(Math.pow(ocR,2)-Math.pow(icR,2))/(2*Math.pow(d,2)) + 2*(ocY-icY)*a/Math.pow(d,2);
					ix2 = (ocX+icX)/2 + (icX-ocX)*(Math.pow(ocR,2)-Math.pow(icR,2))/(2*Math.pow(d,2)) - 2*(ocY-icY)*a/Math.pow(d,2);
					iy1 = (ocY+icY)/2 + (icY-ocY)*(Math.pow(ocR,2)-Math.pow(icR,2))/(2*Math.pow(d,2)) - 2*(ocX-icX)*a/Math.pow(d,2);
					iy2 = (ocY+icY)/2 + (icY-ocY)*(Math.pow(ocR,2)-Math.pow(icR,2))/(2*Math.pow(d,2)) + 2*(ocX-icX)*a/Math.pow(d,2);

					// y coordinates of the original and inversion circles are the same
					if (icY == ocY) {
						// inverted line is vertical
						ix0 = ix1;
						iy0 = 0;
						ixn = ix1;
						iyn = CANVAS_HEIGHT;
					}
					else {
						// http://www.ambrsoft.com/TicRgoCalc/Circles2/circle2intersection/CircleCircleIntersection.htm
						// Use the equation of the line connecting the two intersection points
						ix0 = 0;
						iy0 = (ocX-icX)*ix0/(icY-ocY) + ((Math.pow(ocR,2)-Math.pow(icR,2))+(Math.pow(icX,2)-Math.pow(ocX,2))+(Math.pow(icY,2)-Math.pow(ocY,2)))/(2*(icY-ocY));
						ixn = CANVAS_WIDTH;
						iyn = (ocX-icX)*ixn/(icY-ocY) + ((Math.pow(ocR,2)-Math.pow(icR,2))+(Math.pow(icX,2)-Math.pow(ocX,2))+(Math.pow(icY,2)-Math.pow(ocY,2)))/(2*(icY-ocY));
					}
				}

				// Round the coordinates of the starting and ending points to draw the inverted line
				ix0 = Math.round(ix0);
				iy0 = Math.round(iy0);
				ixn = Math.round(ixn);
				iyn = Math.round(iyn);
				
				// Build the equation of the inverted line
				if (ix0 == ixn)
					invertedCircle.l = 'x=' + ix0;
				else if (iy0 == iyn)
					invertedCircle.l = 'y=' + iy0;
				else {
					m = (iyn-iy0)/(ixn-ix0);
					b = iy0 - m*ix0;
					invertedCircle.l = 'y=' + m.toFixed(2) + 'x+' + Math.round(b);
				}

				// draw the inverted line
				drawLine(context, ix0, iy0, ixn, iyn, circleColor);
			}
			// original circle that doesn't pass through the center of the inversion circle will be inverted as a circle
			else {
				// s = icR^2 / ((ocX-icX)^2 + (ocY-icY)^2 - ocR^2)
				s = Math.pow(icR,2) / denom;
				invertedCircle.x = Math.round(icX + s*(ocX-icX));
				invertedCircle.y = Math.round(icY + s*(ocY-icY));
				invertedCircle.r = Math.round(Math.abs(s)*ocR);
				drawCircle(context, invertedCircle.x, invertedCircle.y, invertedCircle.r, circleColor, fillColor, transparency);
				
				// homothety is enabled
				if (showHomothety) {
					// show line from the center of the inversion circle to the center of the inverted circle
					drawLine(context, icX, icY, invertedCircle.x, invertedCircle.y, 'black');
					
					// show height from the center of the inverted circle to the diameter of the semicircles
					drawLine(context, invertedCircle.x, invertedCircle.y, invertedCircle.x, icY, 'black');
				}
			}
			
			// return the inverted circle
			return invertedCircle;
		}

		// draw a pappus chain
		function drawPappusChain(context, lcX, lcY, r1, r2) {
			// initialize the list of circles in the pappus chain to blank
			var pappusChain = [];
			
			// draw outer semicircle
			drawSemicircle(context, lcX+r1+r2, lcY, r1+r2, 'green', 'white', 1);
			
			// draw the diameter common to all semicircles
			drawLine(context, lcX, lcY, lcX+2*(r1+r2), lcY, 'green');
			
			// draw left inner semicircle
			drawSemicircle(context, lcX+r1, lcY, r1, 'black', 'white', 1);

			// draw right inner semicircle
			drawSemicircle(context, lcX+2*r1+r2, lcY, r2, 'black', 'white', 1);

			// http://mathworld.wolfram.com/PappusChain.html
			// r=AB/AC i.e. r=2r1/(2r1+2r2)=r1/(r1+r2)
			// set the diameter of the outer semicircle
			d = 2 * (r1+r2);
			
			// loop to draw the circles in the pappus chain
			for(n = 1; n < PAPPUS_CHAIN_CIRCLE_COUNT+1; n++){
				// chain circle features
				var chainCircle = {};

				// bigger left semicircle or equal semicircles
				if (r1 >= r2) {
					// ratio of the left semicircle to the outer one
					r = r1 / (r1+r2);
					
					// calculate chain circle coordinates and radius
					xn = r*(1+r) / (2*(Math.pow(n,2)*Math.pow(1-r,2)+r));
					yn = n*r*(1-r) / (Math.pow(n,2)*Math.pow(1-r,2)+r);
					rn = (1-r)*r / (2*(Math.pow(n,2)*Math.pow(1-r,2)+r));
					
					// draw chain circle
					drawCircle(context, lcX+d*xn, lcY+d*yn, d*rn, COLOR_INVERTED, 'white', 1);

					// draw a second chain circle for equal semicircles
					if (r1 == r2)
						drawCircle(context, lcX+d*(1-xn), lcY+d*yn, d*rn, COLOR_INVERTED, 'white', 1);
					
					// show height from the center of the circle in the chain
					if (showHomothety)
						drawLine(context, lcX+d*xn, lcY+d*yn, lcX+d*xn, lcY, 'black');
				}
				// smaller left semicircle
				else {
					// ratio of the right semicircle to the outer one
					r = r2 / (r1+r2);
					
					// calculate chain circle coordinates and radius
					xn = r*(1+r) / (2*(Math.pow(n,2)*Math.pow(1-r,2)+r));
					yn = n*r*(1-r) / (Math.pow(n,2)*Math.pow(1-r,2)+r);
					rn = (1-r)*r / (2*(Math.pow(n,2)*Math.pow(1-r,2)+r));
					
					// draw chain circle
					drawCircle(context, lcX+d*(1-xn), lcY+d*yn, d*rn, COLOR_INVERTED, 'white', 1);
					
					// show height from the center of the circle in the chain
					if (showHomothety)
						drawLine(context, lcX+d*(1-xn), lcY+d*yn, lcX+d*(1-xn), lcY, 'black');
				}

				// add circle to pappus chain
				chainCircle['radius'] = d*rn;
				chainCircle['height'] = d*yn;
				pappusChain.push(chainCircle);

				// exit the loop if the radius is too small
				if (rn < MIN_RADIUS_TO_DISPLAY_IN_PAPPUS_CHAIN)
					break;
			}
			
			// return the pappus chain
			return pappusChain;
		}

		// invert a pappus chain
		function invertPappusChain(context, icX, icY, lcX, lcY, r1, r2, circleColor, fillColor) {
			//https://www.cut-the-knot.org/Curriculum/Geometry/InversionInArbelos.shtml
			// invert outer semicircle
			invertCircle(context, icX, icY, 2*(r1+r2), lcX+r1+r2, lcY, r1+r2, 'green', fillColor, 1);
			
			// invert left inner semicircle
			invertCircle(context, icX, icY, 2*(r1+r2), lcX+r1, lcY, r1, 'black', fillColor, 1);
			
			// invert right inner semicircle
			invertCircle(context, icX, icY, 2*(r1+r2), lcX+2*r1+r2, lcY, r2, COLOR_INVERTED, fillColor, 1);
			
			// diameter of the outer semicircle
			d = 2 * (r1+r2);
			
			// ratio of the bigger semicircle to the outer one
			if (r1 >= r2)
				r = r1 / (r1+r2); 
			else
				r = r2 / (r1+r2); 

			// invert each circle in the pappus chain
			for(n = 1; n < PAPPUS_CHAIN_INVERSE_COUNT+1; n++){
				xn = r*(1+r) / (2*(Math.pow(n,2)*Math.pow(1-r,2)+r));
				yn = n*r*(1-r) / (Math.pow(n,2)*Math.pow(1-r,2)+r);
				rn = (1-r)*r / (2*(Math.pow(n,2)*Math.pow(1-r,2)+r));
				
				// bigger left semicircle or equal semicircles
				if (r1 >= r2)
					invertCircle(context, icX, icY, 2*(r1+r2), lcX+d*xn, lcY+d*yn, d*rn, COLOR_INVERTED, fillColor, 1);
				// smaller left semicircle
				else
					invertCircle(context, icX, icY, 2*(r1+r2), lcX+d*(1-xn), lcY+d*yn, d*rn, COLOR_INVERTED, fillColor, 1);
			}
		}
	</script>
